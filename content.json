{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"书单","date":"2019-01-11T02:58:06.971Z","updated":"2019-01-02T07:50:11.790Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-01-11T03:01:41.796Z","updated":"2019-01-02T07:50:11.790Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-01-18T07:23:07.452Z","updated":"2019-01-18T07:23:07.452Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930&#123; name: 'znn' age: 24, gender: '男', profession: 'Web Developer &amp; Designer', experience: '4年', github: 'https://github.com/znnspace', blog: 'http://blog.znnspace.com', email: 'znnspace@foxmail.com', description: '致力于网站建设与前端用户体验设计', skills: [ ['Html', 'Javascript', 'jQuery', 'CSS', 'ES6', 'Node'], ['Webpack', 'Gulp'], ['Less','Sass'], ['Git', 'SVN'], ['Vue'], ['Bootstrap', 'SUI Mobile', 'light7'], ['WordPress', 'OpenCart'], ['平面设计'] ], devTools: [ ['Sublime Text', 'Visual Studio Code', 'Notepad++'], ['Chrome DevTools', 'Fiddler'], ['SourceTree', 'TortoiseSVN'], ['SwitchHosts'], ['Navicat', 'XAMPP'], ] &#125;"},{"title":"友情链接","date":"2019-01-18T07:01:24.126Z","updated":"2019-01-02T07:50:11.790Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-01-18T07:25:43.238Z","updated":"2019-01-02T07:50:11.790Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-01-18T07:23:39.338Z","updated":"2019-01-02T07:50:11.790Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"分布式锁之Redis实现","slug":"分布式锁之Redis实现","date":"2019-03-04T08:45:27.633Z","updated":"2019-03-08T07:57:54.039Z","comments":true,"path":"2019/03/04/分布式锁之Redis实现/","link":"","permalink":"http://yoursite.com/2019/03/04/分布式锁之Redis实现/","excerpt":"","text":"在Java中，关于锁我想大家都很熟悉。在并发编程中，我们通过锁，来避免由于竞争而造成的数据不一致问题。通常，我们以synchronized 、Lock来使用它。 但是Java中的锁，只能保证在同一个JVM进程内中执行。如果在分布式集群环境下呢？ 一、分布式锁分布式锁，是一种思想，它的实现方式有很多。比如，我们将沙滩当做分布式锁的组件，那么它看起来应该是这样的： 加锁 在沙滩上踩一脚，留下自己的脚印，就对应了加锁操作。其他进程或者线程，看到沙滩上已经有脚印，证明锁已被别人持有，则等待。 解锁 把脚印从沙滩上抹去，就是解锁的过程。 锁超时 为了避免死锁，我们可以设置一阵风，在单位时间后刮起，将脚印自动抹去。 分布式锁的实现有很多，比如基于数据库、memcached、Redis、系统文件、zookeeper等。它们的核心的理念跟上面的过程大致相同。 二、redis我们先来看如何通过单节点Redis实现一个简单的分布式锁。 1、加锁加锁实际上就是在redis中，给Key键设置一个值，为避免死锁，并给定一个过期时间。 1SET lock_key random_value NX PX 5000 值得注意的是： random_value 是客户端生成的唯一的字符串。 NX 代表只在键不存在时，才对键进行设置操作。 PX 5000 设置键的过期时间为5000毫秒。 这样，如果上面的命令执行成功，则证明客户端获取到了锁。 2、解锁解锁的过程就是将Key键删除。但也不能乱删，不能说客户端1的请求将客户端2的锁给删除掉。这时候random_value的作用就体现出来。 为了保证解锁操作的原子性，我们用LUA脚本完成这一操作。先判断当前锁的字符串是否与传入的值相等，是的话就删除Key，解锁成功。 12345if redis.call(&apos;get&apos;,KEYS[1]) == ARGV[1] then return redis.call(&apos;del&apos;,KEYS[1]) else return 0 end 3、实现首先，我们在pom文件中，引入Jedis。在这里，笔者用的是最新版本，注意由于版本的不同，API可能有所差异。 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt; 加锁的过程很简单，就是通过SET指令来设置值，成功则返回；否则就循环等待，在timeout时间内仍未获取到锁，则获取失败。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Servicepublic class RedisLock &#123; Logger logger = LoggerFactory.getLogger(this.getClass()); private String lock_key = &quot;redis_lock&quot;; //锁键 protected long internalLockLeaseTime = 30000;//锁过期时间 private long timeout = 999999; //获取锁的超时时间 //SET命令的参数 SetParams params = SetParams.setParams().nx().px(internalLockLeaseTime); @Autowired JedisPool jedisPool; /** * 加锁 * @param id * @return */ public boolean lock(String id)&#123; Jedis jedis = jedisPool.getResource(); Long start = System.currentTimeMillis(); try&#123; for(;;)&#123; //SET命令返回OK ，则证明获取锁成功 String lock = jedis.set(lock_key, id, params); if(&quot;OK&quot;.equals(lock))&#123; return true; &#125; //否则循环等待，在timeout时间内仍未获取到锁，则获取失败 long l = System.currentTimeMillis() - start; if (l&gt;=timeout) &#123; return false; &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;finally &#123; jedis.close(); &#125; &#125;&#125; 解锁我们通过jedis.eval来执行一段LUA就可以。将锁的Key键和生成的字符串当做参数传进来。 123456789101112131415161718192021222324/** * 解锁 * @param id * @return */ public boolean unlock(String id)&#123; Jedis jedis = jedisPool.getResource(); String script = &quot;if redis.call(&apos;get&apos;,KEYS[1]) == ARGV[1] then&quot; + &quot; return redis.call(&apos;del&apos;,KEYS[1]) &quot; + &quot;else&quot; + &quot; return 0 &quot; + &quot;end&quot;; try &#123; Object result = jedis.eval(script, Collections.singletonList(lock_key), Collections.singletonList(id)); if(&quot;1&quot;.equals(result.toString()))&#123; return true; &#125; return false; &#125;finally &#123; jedis.close(); &#125; &#125; 最后，我们可以在多线程环境下测试一下。我们开启1000个线程，对count进行累加。调用的时候，关键是唯一字符串的生成。这里，笔者使用的是Snowflake算法。 12345678910111213141516171819202122232425262728293031323334353637@Controllerpublic class IndexController &#123; @Autowired RedisLock redisLock; int count = 0; @RequestMapping(&quot;/index&quot;) @ResponseBody public String index() throws InterruptedException &#123; int clientcount =1000; CountDownLatch countDownLatch = new CountDownLatch(clientcount); ExecutorService executorService = Executors.newFixedThreadPool(clientcount); long start = System.currentTimeMillis(); for (int i = 0;i&lt;clientcount;i++)&#123; executorService.execute(() -&gt; &#123; //通过Snowflake算法获取唯一的ID字符串 String id = IdUtil.getId(); try &#123; redisLock.lock(id); count++; &#125;finally &#123; redisLock.unlock(id); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); long end = System.currentTimeMillis(); logger.info(&quot;执行线程数:&#123;&#125;,总耗时:&#123;&#125;,count数为:&#123;&#125;&quot;,clientcount,end-start,count); return &quot;Hello&quot;; &#125;&#125; 至此，单节点Redis的分布式锁的实现就已经完成了。比较简单，但是问题也比较大，最重要的一点是，锁不具有可重入性。 三、redisson Redisson是架设在Redis基础上的一个Java驻内存数据网格（In-Memory Data Grid）。充分的利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。 相对于Jedis而言，Redisson强大的一批。当然了，随之而来的就是它的复杂性。它里面也实现了分布式锁，而且包含多种类型的锁，更多请参阅分布式锁和同步器 1、可重入锁上面我们自己实现的Redis分布式锁，其实不具有可重入性。那么下面我们先来看看Redisson中如何调用可重入锁。 在这里，笔者使用的是它的最新版本，3.10.1。 12345&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.10.1&lt;/version&gt;&lt;/dependency&gt; 首先，通过配置获取RedissonClient客户端的实例，然后getLock获取锁的实例，进行操作即可。 123456789101112131415public static void main(String[] args) &#123; Config config = new Config(); config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;); config.useSingleServer().setPassword(&quot;redis1234&quot;); final RedissonClient client = Redisson.create(config); RLock lock = client.getLock(&quot;lock1&quot;); try&#123; lock.lock(); &#125;finally&#123; lock.unlock(); &#125;&#125; 2、获取锁实例我们先来看RLock lock = client.getLock(&quot;lock1&quot;); 这句代码就是为了获取锁的实例，然后我们可以看到它返回的是一个RedissonLock对象。 1234public RLock getLock(String name) &#123; return new RedissonLock(connectionManager.getCommandExecutor(), name);&#125;复制代码 在RedissonLock构造方法中，主要初始化一些属性。 1234567891011public RedissonLock(CommandAsyncExecutor commandExecutor, String name) &#123; super(commandExecutor, name); //命令执行器 this.commandExecutor = commandExecutor; //UUID字符串 this.id = commandExecutor.getConnectionManager().getId(); //内部锁过期时间 this.internalLockLeaseTime = commandExecutor. getConnectionManager().getCfg().getLockWatchdogTimeout(); this.entryName = id + &quot;:&quot; + name;&#125; 3、加锁当我们调用lock方法，定位到lockInterruptibly。在这里，完成了加锁的逻辑。 1234567891011121314151617181920212223242526272829303132333435public void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedException &#123; //当前线程ID long threadId = Thread.currentThread().getId(); //尝试获取锁 Long ttl = tryAcquire(leaseTime, unit, threadId); // 如果ttl为空，则证明获取锁成功 if (ttl == null) &#123; return; &#125; //如果获取锁失败，则订阅到对应这个锁的channel RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId); commandExecutor.syncSubscription(future); try &#123; while (true) &#123; //再次尝试获取锁 ttl = tryAcquire(leaseTime, unit, threadId); //ttl为空，说明成功获取锁，返回 if (ttl == null) &#123; break; &#125; //ttl大于0 则等待ttl时间后继续尝试获取 if (ttl &gt;= 0) &#123; getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS); &#125; else &#123; getEntry(threadId).getLatch().acquire(); &#125; &#125; &#125; finally &#123; //取消对channel的订阅 unsubscribe(future, threadId); &#125; //get(lockAsync(leaseTime, unit));&#125; 如上代码，就是加锁的全过程。先调用tryAcquire来获取锁，如果返回值ttl为空，则证明加锁成功，返回；如果不为空，则证明加锁失败。这时候，它会订阅这个锁的Channel，等待锁释放的消息，然后重新尝试获取锁。流程如下： 获取锁 获取锁的过程是怎样的呢？接下来就要看tryAcquire方法。在这里，它有两种处理方式，一种是带有过期时间的锁，一种是不带过期时间的锁。 1234567891011121314151617181920212223242526272829private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long leaseTime, TimeUnit unit, final long threadId) &#123; //如果带有过期时间，则按照普通方式获取锁 if (leaseTime != -1) &#123; return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG); &#125; //先按照30秒的过期时间来执行获取锁的方法 RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync( commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG); //如果还持有这个锁，则开启定时任务不断刷新该锁的过期时间 ttlRemainingFuture.addListener(new FutureListener&lt;Long&gt;() &#123; @Override public void operationComplete(Future&lt;Long&gt; future) throws Exception &#123; if (!future.isSuccess()) &#123; return; &#125; Long ttlRemaining = future.getNow(); // lock acquired if (ttlRemaining == null) &#123; scheduleExpirationRenewal(threadId); &#125; &#125; &#125;); return ttlRemainingFuture;&#125; 接着往下看，tryLockInnerAsync方法是真正执行获取锁的逻辑，它是一段LUA脚本代码。在这里，它使用的是hash数据结构。 123456789101112131415161718192021222324&lt;T&gt; RFuture&lt;T&gt; tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&lt;T&gt; command) &#123; //过期时间 internalLockLeaseTime = unit.toMillis(leaseTime); return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command, //如果锁不存在，则通过hset设置它的值，并设置过期时间 &quot;if (redis.call(&apos;exists&apos;, KEYS[1]) == 0) then &quot; + &quot;redis.call(&apos;hset&apos;, KEYS[1], ARGV[2], 1); &quot; + &quot;redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[1]); &quot; + &quot;return nil; &quot; + &quot;end; &quot; + //如果锁已存在，并且锁的是当前线程，则通过hincrby给数值递增1 &quot;if (redis.call(&apos;hexists&apos;, KEYS[1], ARGV[2]) == 1) then &quot; + &quot;redis.call(&apos;hincrby&apos;, KEYS[1], ARGV[2], 1); &quot; + &quot;redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[1]); &quot; + &quot;return nil; &quot; + &quot;end; &quot; + //如果锁已存在，但并非本线程，则返回过期时间ttl &quot;return redis.call(&apos;pttl&apos;, KEYS[1]);&quot;, Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId)); &#125; 这段LUA代码看起来并不复杂，有三个判断： 通过exists判断，如果锁不存在，则设置值和过期时间，加锁成功 通过hexists判断，如果锁已存在，并且锁的是当前线程，则证明是重入锁，加锁成功 如果锁已存在，但锁的不是当前线程，则证明有其他线程持有锁。返回当前锁的过期时间，加锁失败 加锁成功后，在redis的内存数据中，就有一条hash结构的数据。Key为锁的名称；field为随机字符串+线程ID；值为1。如果同一线程多次调用lock方法，值递增1。 123127.0.0.1:6379&gt; hgetall lock11) \"b5ae0be4-5623-45a5-8faa-ab7eb167ce87:1\"2) \"1\" 4、解锁我们通过调用unlock方法来解锁。 1234567891011121314151617181920212223242526272829303132333435public RFuture&lt;Void&gt; unlockAsync(final long threadId) &#123; final RPromise&lt;Void&gt; result = new RedissonPromise&lt;Void&gt;(); //解锁方法 RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId); future.addListener(new FutureListener&lt;Boolean&gt;() &#123; @Override public void operationComplete(Future&lt;Boolean&gt; future) throws Exception &#123; if (!future.isSuccess()) &#123; cancelExpirationRenewal(threadId); result.tryFailure(future.cause()); return; &#125; //获取返回值 Boolean opStatus = future.getNow(); //如果返回空，则证明解锁的线程和当前锁不是同一个线程，抛出异常 if (opStatus == null) &#123; IllegalMonitorStateException cause = new IllegalMonitorStateException(&quot; attempt to unlock lock, not locked by current thread by node id: &quot; + id + &quot; thread-id: &quot; + threadId); result.tryFailure(cause); return; &#125; //解锁成功，取消刷新过期时间的那个定时任务 if (opStatus) &#123; cancelExpirationRenewal(null); &#125; result.trySuccess(null); &#125; &#125;); return result;&#125; 然后我们再看unlockInnerAsync方法。这里也是一段LUA脚本代码。 1234567891011121314151617181920212223242526272829protected RFuture&lt;Boolean&gt; unlockInnerAsync(long threadId) &#123; return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, EVAL, //如果锁已经不存在， 发布锁释放的消息 &quot;if (redis.call(&apos;exists&apos;, KEYS[1]) == 0) then &quot; + &quot;redis.call(&apos;publish&apos;, KEYS[2], ARGV[1]); &quot; + &quot;return 1; &quot; + &quot;end;&quot; + //如果释放锁的线程和已存在锁的线程不是同一个线程，返回null &quot;if (redis.call(&apos;hexists&apos;, KEYS[1], ARGV[3]) == 0) then &quot; + &quot;return nil;&quot; + &quot;end; &quot; + //通过hincrby递减1的方式，释放一次锁 //若剩余次数大于0 ，则刷新过期时间 &quot;local counter = redis.call(&apos;hincrby&apos;, KEYS[1], ARGV[3], -1); &quot; + &quot;if (counter &gt; 0) then &quot; + &quot;redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[2]); &quot; + &quot;return 0; &quot; + //否则证明锁已经释放，删除key并发布锁释放的消息 &quot;else &quot; + &quot;redis.call(&apos;del&apos;, KEYS[1]); &quot; + &quot;redis.call(&apos;publish&apos;, KEYS[2], ARGV[1]); &quot; + &quot;return 1; &quot;+ &quot;end; &quot; + &quot;return nil;&quot;, Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));&#125; 如上代码，就是释放锁的逻辑。同样的，它也是有三个判断： 如果锁已经不存在，通过publish发布锁释放的消息，解锁成功 如果解锁的线程和当前锁的线程不是同一个，解锁失败，抛出异常 通过hincrby递减1，先释放一次锁。若剩余次数还大于0，则证明当前锁是重入锁，刷新过期时间；若剩余次数小于0，删除key并发布锁释放的消息，解锁成功 至此，Redisson中的可重入锁的逻辑，就分析完了。但值得注意的是，上面的两种实现方式都是针对单机Redis实例而进行的。如果我们有多个Redis实例，请参阅Redlock算法。该算法的具体内容，请参考redis.cn/topics/dist… 作者：清幽之地 链接：https://juejin.im/post/5c6e25aaf265da2dc538b4f9 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"分布式锁","slug":"分布式锁","permalink":"http://yoursite.com/categories/分布式锁/"}],"tags":[{"name":"分布式锁","slug":"分布式锁","permalink":"http://yoursite.com/tags/分布式锁/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-01-02T07:49:20.670Z","updated":"2019-01-02T07:49:20.670Z","comments":true,"path":"2019/01/02/hello-world/","link":"","permalink":"http://yoursite.com/2019/01/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}